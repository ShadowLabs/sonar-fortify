<h2>ABSTRACT</h2>
<p>
  Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.
</p>
<h2>EXPLANATION</h2>
<p>
  Database access control errors occur when:<br /><br />1.	Data enters a program from an untrusted source.<br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>. <br /></p><br /><br />2.	The data is used to specify the value of a primary key in a SQL query. <br /><p><br />In this case the data is used by <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br /><br /><IfNotDef var="ConditionalDescriptions"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user. <br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />String query = "SELECT * FROM invoices WHERE id = ?";<br />PreparedStatement stmt = conn.prepareStatement(query);<br />stmt.setInt(1, id);<br />ResultSet results = stmt.execute();<br />...<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="trace:/javax?\.sql/ trace:!javax.persistence"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user. <br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />String query = "SELECT * FROM invoices WHERE id = ?";<br />PreparedStatement stmt = conn.prepareStatement(query);<br />stmt.setInt(1, id);<br />ResultSet results = stmt.execute();<br />...<br /></pre><br /></ConditionalText><br /><ConditionalText condition="trace:javax.persistence"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user. <br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />String query = "SELECT * FROM invoices WHERE id = ?";<br />Query stmt = entmgr.createQuery(query).setParameter(0, id);<br />List invoices = stmt.getResultList();<br />...<br /></pre><br /><br /><b>Example 2:</b> The following code demonstrates the same functionality as above, but maps the returned data to Persistence entities via annotations. It also uses named, rather than positional, parameters to construct its query.<br /><br /><pre><br />...<br />@Entity<br />@NamedQuery(name="invoiceQuery", query="SELECT * FROM invoices WHERE id = :invID")<br />public class Invoice {<br />   ...<br />}<br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />Query stmt = sess.getNamedQuery("invoiceQuery").setParameter("invID", id);<br />List invoices = stmt.getResultList();<br /></pre><br /><br /><b>Example 3:</b> In this example, the code uses XML mappings, rather than annotations, to achieve the same effect as Example 2.<br /><br /><pre><br />&lt;entity-mappings&gt;<br />   ...<br />   &lt;entity name="invoice" class="com.acme.Invoice"&gt;<br />      &lt;named-query name="invoiceQuery"&gt;<br />         &lt;query&gt;SELECT * FROM invoices WHERE id = :invID&lt;/query&gt;<br />      &lt;/named-query&gt;<br />      ...<br />   &lt;/entity&gt;<br />   ...<br />&lt;/entity-mappings&gt;<br /></pre><br /><br />The following code then executes the query in a separate Java source file.<br /><br /><pre><br />id = Integer.decode(request.getParameter("invoiceID"));<br />Query stmt = sess.getNamedQuery("invoiceQuery").setParameter("invID", id);<br />List invoices = stmt.getResultList();<br /></pre><br /></ConditionalText><br /><ConditionalText condition="trace:org.hibernate trace:net.sf.hibernate"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user. <br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />String query = "SELECT * FROM invoices WHERE id = ?";<br />Query stmt = sess.createSQLQuery(query).setInteger(0, id);<br />List invoices = stmt.list();<br />...<br /></pre><br /><br /><b>Example 2:</b> In this example, the code uses a mappings file to generate named SQL query equivalent to the logic in Example 1. Likewise, named queries separate the SQL logic from the data and helps prevent SQL injection vulnerabilities.<br /><br /><pre><br />...<br />&lt;sql-query name="invoiceQuery"&gt;<br />   &lt;return alias="invoice" class="com.acme.Invoice"&gt;<br />   SELECT * FROM invoices WHERE id = :invID<br />&lt;/sql-query&gt;<br />...<br /></pre><br /><br />Then, the Java source code executes the above query.<br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />Query stmt = sess.getNamedQuery("invoiceQuery").setInteger("invID", id);<br />List invoices = stmt.list();<br />...<br /></pre><br /><br /><b>Example 3:</b> The following code implements similar functionality to the previous two examples in HQL. It uses Hibernate annotations in lieu of mappings files to generate named HQL queries.<br /><br /><pre><br />@NamedQuery(name = "invoiceQuery",<br />            query = "SELECT * FROM invoices WHERE id = :invID")<br />public class Invoice {<br />   ...<br />}<br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />Query stmt = sess.getNamedQuery("invoiceQuery").setInteger("invID", id);<br />List invoices = stmt.list();<br />...<br /></pre><br /></ConditionalText><br /><ConditionalText condition="trace:!/javax?\.sql|javax\.persistence|org\.hibernate|net\.sf\.hibernate/"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user. <br /><br /><pre><br />...<br />id = Integer.decode(request.getParameter("invoiceID"));<br />String query = "SELECT * FROM invoices WHERE id = ?";<br />PreparedStatement stmt = conn.prepareStatement(query);<br />stmt.setInt(1, id);<br />ResultSet results = stmt.execute();<br />...<br /></pre><br /></ConditionalText><br /></p></IfDef><br /><br />The problem is that the developer has failed to consider all of the possible values of <code>id</code>. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.<br /><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="tracenode:form field validator tracenode:action form validator tracenode:action declaration tracenode:action field validator">A number of modern web frameworks provide mechanisms for performing validation of user input. Struts and Struts 2 are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</ConditionalText><br /></p></IfDef><br /><IfNotDef var="ConditionalDescriptions"><br />A number of modern web frameworks provide mechanisms for performing validation of user input. Struts and Struts 2 are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br /></IfNotDef>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>