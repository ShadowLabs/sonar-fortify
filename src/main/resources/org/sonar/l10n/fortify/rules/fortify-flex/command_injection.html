<h2>ABSTRACT</h2>
<p>
  Executing commands from an untrusted source or in an untrusted environment can cause an application to execute malicious commands on behalf of an attacker.
</p>
<h2>EXPLANATION</h2>
<p>
  Command injection vulnerabilities take two forms:<br /><br />- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.<br /><br />- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.<br /><br />In this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:<br /><br />1. Data enters the application from an untrusted source.<br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>.<br /></p><br /><IfDef var="ConditionalDescriptions"><br /> <p><br />  <ConditionalText condition="taint:number"><br />Even though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.<br />  </ConditionalText><br /> </p><br /></IfDef><br /><br />2. The data is used as or as part of a string representing a command that is executed by the application.<br /><p><br />In this case the command is executed by <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br />3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.<br /><br /><b>Example 1:</b> The following code uses input from configuration file to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory.<br /><br /><pre><br />        ...<br />        var fs:FileStream = new FileStream();<br />        fs.open(new File(String(configStream.readObject())+".txt"), FileMode.READ);<br />        home = String(fs.readObject(home));<br />        var cmd:String = home + INITCMD;<br />        fscommand("exec", cmd);<br />        ...<br /></pre><br /><br />The code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the contents of the configuration file <code>configStream</code> to point to a different path containing a malicious version of <code>INITCMD</code>. Because the program does not validate the value read from the file, if an attacker can control that value, then they can fool the application into running malicious code and take control of the system.<br /><br /><b>Example 2:</b> The following code is from an administrative web application designed to allow users to kick off a backup of an Oracle database using a batch-file wrapper around the <code>rman</code> utility and then run a <code>cleanup.bat</code> script to delete some temporary files. The script <code>rmanDB.bat</code> accepts a single command line parameter, which specifies what type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user.<br /><br /><pre><br />        ...<br />        var params:Object = LoaderInfo(this.root.loaderInfo).parameters;<br />        var btype:String = String(params["backuptype"]);<br />        var cmd:String = "cmd.exe /K \"c:\\util\\rmanDB.bat " + btype + "&amp;&amp;c:\\utl\\cleanup.bat\"";<br />        fscommand("exec", cmd);<br />        ...<br /></pre><br /><br />The problem here is that the program does not do any validation on the <code>backuptype</code> parameter read from the user. Typically the <code>fscommand()</code> function will not execute multiple commands, but in this case the program first runs the <code>cmd.exe</code> shell in order to run multiple commands with a single call to <code>fscommnd()</code>. Once the shell is invoked, it will happily execute multiple commands separated by two ampersands. If an attacker passes a string of the form <code>"&amp;&amp; del c:\\dbms\\*.*"</code>, then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well.<br /><br /><b>Example 3:</b> The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a <code>make</code> command in the <code>/var/yp</code> directory, the code for which is shown below.<br /><br /><pre><br />        ...<br />        fscommand("exec", "make");<br />        ...<br /></pre><br /><br />The problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to <code>fscommand()</code>. If an attacker can modify the <code>$PATH</code> variable to point to a malicious binary called <code>make</code> and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's <code>make</code> will now be run with these privileges, possibly giving the attacker complete control of the system.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>