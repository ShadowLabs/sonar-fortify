<h2>ABSTRACT</h2>
<p>
  Executing commands that include unvalidated user input can cause an application to act on behalf of an attacker.
</p>
<h2>EXPLANATION</h2>
<p>
  Command injection vulnerabilities take two forms:<br /><br />- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.<br /><br />- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.<br /><br />In this case we are primarily concerned with the first scenario, in which an attacker explicitly controls the command that is executed. Command injection vulnerabilities of this type occur when:<br /><br />1. Data enters the application from an untrusted source.<br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>.<br /></p><br /><IfDef var="ConditionalDescriptions"><br /> <p><br />  <ConditionalText condition="taint:number"><br />Even though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.<br />  </ConditionalText><br /> </p><br /></IfDef><br /><br />2. The data is part of a string that is executed as a command by the application. <br /><p><br />In this case the command is executed by <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br /><br />3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.<br /> <br /><b>Example 1:</b> The following simple program accepts a filename as a command line argument and displays the contents of the file back to the user. The program is installed <code>setuid root</code> because it is intended for use as a learning tool to allow system administrators in-training to inspect privileged system files without giving them the ability to modify them or damage the system. <br /><br /><pre><br />int main(char* argc, char** argv) {<br />	char cmd[CMD_MAX] = "/usr/bin/cat ";	<br />	strcat(cmd, argv[1]);<br />	system(cmd);	<br />}<br /></pre><br /><br />Because the program runs with <code>root</code> privileges, the call to <code>system()</code> also executes with <code>root</code> privileges. If a user specifies a standard filename, the call works as expected. However, if an attacker passes a string of the form <code>";rm -rf /"</code>, then the call to <code>system()</code> fails to execute <code>cat</code> due to a lack of arguments and then plows on to recursively delete the contents of the root partition. <br /><br /><b>Example 2:</b> The following code from a privileged program uses the environment variable <code>$APPHOME</code> to determine the application's installation directory and then executes an initialization script in that directory. <br /><br /><pre><br />	...<br />	char* home=getenv("APPHOME"); 	<br />	char* cmd=(char*)malloc(strlen(home)+strlen(INITCMD));<br />	if (cmd) { <br />		strcpy(cmd,home);<br />		strcat(cmd,INITCMD);<br />		execl(cmd, NULL);<br />	}<br />	...<br /></pre><br /><br />As in Example 1, the code in this example allows an attacker to execute arbitrary commands with the elevated privilege of the application. In this example, the attacker can modify the environment variable <code>$APPHOME</code> to specify a different path containing a malicious version of <code>INITCMD</code>. Because the program does not validate the value read from the environment, by controlling the environment variable the attacker can fool the application into running malicious code.<br /><br />The attacker is using the environment variable to control the command that the program invokes, so the effect of the environment is explicit in this example. We will now turn our attention to what can happen when the attacker can change the way the command is interpreted.<br /><br /><b>Example 3:</b> The code below is from a web-based CGI utility that allows users to change their passwords. The password update process under NIS includes running <code>make</code> in the <code>/var/yp</code> directory. Note that since the program updates password records, it has been installed <code>setuid root</code>.<br /><br />The program invokes <code>make</code> as follows: <br /><br /><pre><br />system("cd /var/yp &amp;&amp; make &amp;&gt; /dev/null");<br /></pre><br /><br />Unlike the previous examples, the command in this example is hardcoded, so an attacker cannot control the argument passed to <code>system()</code>. However, since the program does not specify an absolute path for <code>make</code> and does not scrub any environment variables prior to invoking the command, the attacker can modify their <code>$PATH</code> variable to point to a malicious binary named <code>make</code> and execute the CGI script from a shell prompt. And since the program has been installed <code>setuid root</code>, the attacker's version of <code>make</code> now runs with <code>root</code> privileges. <br /><br />The environment plays a powerful role in the execution of system commands within programs. Functions like <code>system()</code> and <code>exec()</code> use the environment of the program that calls them, and therefore attackers have a potential opportunity to influence the behavior of these calls.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>