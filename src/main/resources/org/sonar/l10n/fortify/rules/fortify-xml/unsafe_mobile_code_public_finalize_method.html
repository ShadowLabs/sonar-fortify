<h2>ABSTRACT</h2>
<p>
  The program violates secure coding principles for mobile code by declaring a <code>finalize()</code>method <code>public</code>.
</p>
<h2>EXPLANATION</h2>
<p>
  A program should never call finalize explicitly, except to call <code>super.finalize()</code> inside an implementation of <code>finalize()</code>. In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke one of your <code>finalize()</code> methods because it is declared with <code>public</code> access. If you are using <code>finalize()</code> as it was designed, there is no reason to declare <code>finalize()</code> with anything other than <code>protected</code> access.<br /> <br /><b>Example 1:</b> The following Java Applet code mistakenly declares a <code>public finalize()</code> method.<br /><br /><pre><br />public final class urlTool extends Applet {<br />public void finalize() {<br />	...<br />}<br />	...<br />}<br /></pre><br /><br />Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>