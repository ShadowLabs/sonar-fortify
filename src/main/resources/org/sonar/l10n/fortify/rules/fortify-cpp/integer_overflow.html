<h2>ABSTRACT</h2>
<p>
  Not accounting for integer overflow can result in logic errors or buffer overflow.
</p>
<h2>EXPLANATION</h2>
<p>
  Integer overflow errors occur when a program fails to account for the fact that an arithmetic operation can result in a quantity either greater than a data type's maximum value or less than its minimum value. These errors often cause problems in memory allocation functions, where user input intersects with an implicit conversion between signed and unsigned values. If an attacker can cause the program to under-allocate memory or interpret a signed value as an unsigned value in a memory operation, the program may be vulnerable to a buffer overflow.<br /><br /><b>Example 1:</b> The following code excerpt from OpenSSH 3.3 demonstrates a classic case of integer overflow:<br /><br /><pre><br />nresp = packet_get_int();<br />if (nresp &gt; 0) {<br /> response = xmalloc(nresp*sizeof(char*));<br /> for (i = 0; i &lt; nresp; i++)<br />  response[i] = packet_get_string(NULL);<br />}<br /></pre><br /><br />If <code>nresp</code> has the value <code>1073741824</code> and <code>sizeof(char*)</code> has its typical value of <code>4</code>, then the result of the operation <code>nresp*sizeof(char*)</code> overflows, and the argument to <code>xmalloc()</code> will be <code>0</code>. Most <code>malloc()</code> implementations will happily allocate a 0-byte buffer, causing the subsequent loop iterations to overflow the heap buffer <code>response</code>.<br /><br /><b>Example 2:</b> This example processes user input comprised of a series of variable-length structures. The first 2 bytes of input dictate the size of the structure to be processed.<br /><br /><pre><br /> char* processNext(char* strm) {<br /> char buf[512];<br /> short len = *(short*) strm;<br /> strm += sizeof(len);<br /> if (len &lt;= 512) {<br />  memcpy(buf, strm, len);<br />  process(buf);<br />  return strm + len;<br /> } else {<br />  return -1;<br /> }<br />}<br /></pre><br /><br />The programmer has set an upper bound on the structure size: if it is larger than <code>512</code>, the input will not be processed. The problem is that <code>len</code> is a signed integer, so the check against the maximum structure length is done with signed integers, but <code>len</code> is converted to an unsigned integer for the call to <code>memcpy()</code>. If <code>len</code> is negative, then it will appear that the structure has an appropriate size (the <code>if</code> branch will be taken), but the amount of memory copied by <code>memcpy()</code> will be quite large, and the attacker will be able to overflow the stack with data in <code>strm</code>.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>