<h2>ABSTRACT</h2>
<p>
  The method uses HTML, XML or other type of encoding that is not always enough to prevent malicious code from reaching the web browser.
</p>
<h2>EXPLANATION</h2>
<p>
  The use of certain encoding constructs, such as ESAPI or AntiXSS, will prevent some, but not all cross-site scripting attacks. Depending on the context in which the data appears, characters beyond the basic &lt;, &gt;, &amp;, and " that are HTML-encoded and those beyond &lt;, &gt;, &amp;, ", and ' that are XML-encoded may take on meta-meaning. Relying on such encoding constructs is equivalent to using a weak blacklist to prevent cross-site scripting and might allow an attacker to inject malicious code that will be executed in the browser. Because accurately identifying the context in which the data appear statically is not always possible, HP Fortify Static Code Analyzer reports cross-site scripting findings even when encoding is applied and presents them as Cross-Site Scripting: Poor Validation issues. <br /><br />The following examples highlight exploitable XSS instances which are encoded using an encoding API:<br /><br /><pre><br />...<br />- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {<br />...<br />    NSString *htmlPage = [NSString stringWithFormat: @"%@/%@/%@", @"...&lt;input type=text onclick=\"", <br />                         [DefaultEncoder encodeForHTML:partAfterSlashSlash],<br />			 @"\" /&gt;"];<br />    UIWebView *webView;<br />    NSString *partAfterSlashSlash = [[url host] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br />    webView = [[UIWebView alloc] initWithFrame:CGRectMake(0.0,0.0,360.0, 480.0)];<br />    [webView loadHTMLString:htmlPage baseURL:nil];<br />...<br /></pre><br /><br />Cross-site scripting (XSS) vulnerabilities occur when:<br /><br />1. Data enters a web page through an untrusted source. In the case of Reflected XSS, the untrusted source is typically through user components, URL scheme handlers, or notifications, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.<br /><br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>. <br /></p><br />2. The data is included in dynamic content that is sent to a UIWebView component without being validated for malicious code. <br /><p><br />In this case the data is weakly validated with XML encoding at <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br />The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br /><br /><br /><b>Example 1:</b> The following Objective-C code segment reads the text portion of a custom URL scheme which was passed to and invoked the application (<code>myapp://input_to_the_application</code>). The untrusted data in the URL is then used to render HTML output in a UIWebView component. <br /><br /><pre><br />...<br />- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url {<br />...<br />    UIWebView *webView;<br />    NSString *partAfterSlashSlash = [[url host] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];<br />    NSString *htmlPage = [NSString stringWithFormat: @"%@/%@/%@", @"...&lt;input type=text onclick=\"callFunction('", <br />                         [DefaultEncoder encodeForHTML:partAfterSlashSlash],<br />			 @"')\" /&gt;"];<br />    webView = [[UIWebView alloc] initWithFrame:CGRectMake(0.0,0.0,360.0, 480.0)];<br />    [webView loadHTMLString:htmlPage baseURL:nil];<br />...<br /></pre><br /><br /><p><br /><br />The code in this example operates correctly if <code>partAfterSlashSlash</code> contains only standard alphanumeric text. If <code> partAfterSlashSlash </code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP page.  This is due to the fact that browsers will reverse HTML encode input passed to a JavaScript event handler at runtime.<br /><br />Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable iOS application back to their own mobile devices. This mechanism of exploiting vulnerable iOS applications is known as Reflected XSS.<br /><br /></p><br /><br /><p><br /><b>Example 2:</b> The following iOS code segment queries a database for an employee with a given ID and outputs the value in the display content of a UIWebView.<br /><br /><pre> <br /><br />    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];<br />    NSEntityDescription *entity = [NSEntityDescription <br />    	entityForName:@"Employee" inManagedObjectContext:context];<br />	[fetchRequest setEntity:entity];<br />    NSArray *fetchedObjects = [context executeFetchRequest:fetchRequest error:&amp;error];<br />    for (NSManagedObject *info in fetchedObjects) {<br />        NSString *htmlPage = [NSString stringWithFormat: @"%@/%@/%@",  @"...&lt;input type=text onclick=\"callFunction('",<br />                         [DefaultEncoder encodeForHTML:[info valueForKey:@"name"]],<br />			 @"')\" /&gt;"];<br />        UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0.0,0.0,360.0, 480.0)];<br />        [webView loadHTMLString:htmlPage baseURL:nil]<br /><br /></pre><br /></p><br /><br />As in Example 1, this code functions correctly when the values of <code>name</code> are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of <code>name</code> is read from a database and is HTML encoded. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. The attacker supplied exploit could bypass encoded characters or place input in a context which is not effected by HTML encoding.  This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br /><br />As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in HTTP content. There are three vectors by which an XSS attack can reach a victim:<br /><br />- As in Example 1, data is read directly from a custom URL scheme and reflected back in the content of a UIWebView response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable iOS application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a custom scheme URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable app. After the app reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br /><br />- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br /><br />- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>