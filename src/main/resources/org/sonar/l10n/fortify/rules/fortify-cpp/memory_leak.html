<h2>ABSTRACT</h2>
<p>
  Memory is allocated but never freed.
</p>
<h2>EXPLANATION</h2>
<p>
  Memory leaks have two common and sometimes overlapping causes:<br /><br />- Error conditions and other exceptional circumstances.<br /><br />- Confusion over which part of the program is responsible for freeing the memory.<br /><p><br />In this case the memory allocated in <Replace key="FirstTraceLocation.file"/> at line <Replace key="FirstTraceLocation.line"/> is not always freed or returned by the function.<br /></p><br />Most memory leaks result in general software reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker might be able to launch a denial of service attack (by crashing the program) or take advantage of other unexpected program behavior resulting from a low memory condition [1].<br /><br /><b>Example 1:</b> The following C function leaks a block of allocated memory if the call to <code>read()</code> fails to return the expected number of bytes:<br /><br /><pre><br />  char* getBlock(int fd) {<br />  char* buf = (char*) malloc(BLOCK_SIZE);<br />  if (!buf) {<br />    return NULL;<br />  }<br />  if (read(fd, buf, BLOCK_SIZE) != BLOCK_SIZE) {<br />    return NULL;<br />  }<br />  return buf;<br />}<br /></pre>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>