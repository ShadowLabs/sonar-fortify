
							<h2>ABSTRACT</h2>
							<p>
							  Authenticating a user without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Session fixation vulnerabilities occur when:<br><br>1. A web application authenticates a user without first invalidating the existing session, thereby continuing to use the session already associated with the user.<br><br>2. An attacker is able to force a known session identifier on a user so that, once the user authenticates, the attacker has access to the authenticated session. <br><br>In the generic exploit of session fixation vulnerabilities, an attacker creates a new session on a web application and records the associated session identifier. The attacker then causes the victim to authenticate against the server using that session identifier, giving the attacker access to the user's account through the active session.<br><br><b>Example:</b> The following example shows a snippet of code from a J2EE web application where the application authenticates users with a direct post to the <code>j_security_check</code>, which typically does not invalidate the existing session before processing the login request. <br><br><pre><br>&lt;form method="POST" action="j_security_check"&gt;<br>&lt;input type="text" name="j_username"&gt;<br>&lt;input type="text" name="j_password"&gt;<br>&lt;/form&gt;<br></pre><br><br>In order to exploit the code above, an attacker could first create a session (perhaps by logging into the application) from a public terminal, record the session identifier assigned by the application, and reset the browser to the login page. Next, a victim sits down at the same public terminal, notices the browser open to the login page of the site, and enters credentials to authenticate against the application. The code responsible for authenticating the victim continues to use the pre-existing session identifier, now the attacker simply uses the session identifier recorded earlier to access the victim's active session, providing nearly unrestricted access to the victim's account for the lifetime of the session. <br><br>Even given a vulnerable application, the success of the specific attack described here is dependent on serveral factors working in the favor of the attacker: access to an unmonitored public terminal, the ability to keep the compromised session active and a victim interested in logging into the vulnerable application on the public terminal. In most circumstances, the first two challenges are surmountable given a sufficient investment of time. Finding a victim who is both using a public terminal and interested in logging into the vulnerable application is possible as well, so long as the site is reasonably popular. The less well known the site is, the lower the odds of an interested victim using the public terminal and the lower the chance of success for the attack vector described above. <br><br>The biggest challenge an attacker faces in exploiting session fixation vulnerabilities is inducing victims to authenticate against the vulnerable application using a session identifier known to the attacker. In the example above, the attacker did this through a direct method that is not subtle and does not scale suitably for attacks involving less well-known web sites. However, do not be lulled into complacency; attackers have many tools in their belts that help bypass the limitations of this attack vector. The most common technique employed by attackers involves taking advantage of cross-site scripting or HTTP response splitting vulnerabilities in the target site [1]. By tricking the victim into submitting a malicious request to a vulnerable application that reflects JavaScript or other code back to the victim's browser, an attacker can create a cookie that will cause the victim to reuse a session identifier controlled by the attacker. <br><br>It is worth noting that cookies are often tied to the top level domain associated with a given URL. If multiple applications reside on the same top level domain, such as bank.example.com and recipes.example.com, a vulnerability in one application can allow an attacker to set a cookie with a fixed session identifier that will be used in all interactions with any application on the domain example.com [2]. <br><br>Other attack vectors include DNS poisoning and related network based attacks where an attacker causes the user to visit a malicious site by redirecting a request for a valid site. Network based attacks typically involve a physical presence on the victim's network or control of a compromised machine on the network, which makes them harder to exploit remotely, their significance should not be overlooked. Less secure session management mechanisms, such as the default implementation in Apache Tomcat, allow session identifiers normally expected in a cookie to be specified on the URL as well, which enables an attacker to cause a victim to use a fixed session identifier simply by emailing a malicious URL. <br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3090 CAT II</em> <br></p>
																									   <p>[5]  <em>Cross-Site Scripting and Header Manipulation Descriptions</em> Fortify, An HP Company<br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 384</em> <br></p>
																									   <p>[7] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Session Fixation</em> <br></p>
																									   <p>[12] D. Whalen <em>The Unofficial Cookie FAQ</em> <br></p>
																														