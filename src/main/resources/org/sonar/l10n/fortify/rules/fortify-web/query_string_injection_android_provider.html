<h2>ABSTRACT</h2>
<p>
   Constructing a SQLite query statement that contains user input can allow an attacker to view unauthorized records.
</p>
<h2>EXPLANATION</h2>
<p>
  Query string injection vulnerabilities occur when:<br />  1. Data enters a program from an untrusted source.<br /><br />  <p><br />  In this case the data enters at <Replace key="SourceFunction"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>.<br />  </p><br /><br />  2. The data is used to dynamically construct a SQLite query string.<br /><br />  <p><br />  In this case the data is passed to <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br />  </p><br /><br />  There is an important distinction between injection attacks against a SQL database and injection attacks against a SQLite database. Unlike SQL injection, SQLite string injection allows malicious users to view unauthorized records, but does not allow them to alter the state of the database in any way.<br /><br />  <b>Example 1:</b> The following code dynamically constructs and executes a SQLite query that searches for invoices associated with a customer and a user-specified product category. The user can also specify the column by which the results should be sorted. Assume that the program has already properly authenticated and set the value of <code>customerID</code> prior to this code segment.<br /><br />  <pre><br />  ...<br />  productCategory = this.getIntent().getExtras().getString("productCategory");<br />  sortColumn = this.getIntent().getExtras().getString("sortColumn");<br />  customerID = getAuthenticatedCustomerID(customerName, customerCredentials);<br />  c = invoicesDB.query(Uri.parse(invoices), columns, "productCategory = '" + productCategory + "' and customerID = '" + customerID + "'", null, null, null, "'" + sortColumn + "'asc", null);<br />  ...<br />  </pre><br /><br />  The query that this code intends to execute looks like:<br /><br />  <pre><br />  select * from invoices<br />  where productCategory = 'Fax Machines'<br />  and customerID = '12345678'<br />  order by 'price' asc<br />  </pre><br /><br />  However, the query is constructed dynamically by concatenating a constant base query string and a user input string <code>productCategory</code>. So the query behaves correctly only if <code>productCategory</code> and <code>sortColumn</code> do not contain single-quote characters. If an attacker provides the string "<code>Fax Machines' or productCategory = \"</code>" for <code>productCategory</code>, and the string "<code>\" order by 'price</code>" for <code>sortColumn</code>, then the query becomes:<br /><br />  <pre><br />  select * from invoices<br />  where productCategory = 'Fax Machines' or productCategory = "'<br />  and customerID = '12345678'<br />  order by '" order by 'price' asc<br />  </pre><br /><br />  or, in a more readable form,<br /><br />  <pre><br />  select * from invoices<br />  where productCategory = 'Fax Machines'<br />  or productCategory = "' and customerID = '12345678' order by '"<br />  order by 'price' asc<br />  </pre><br /><br /> These inputs allow an attacker to bypass the required authentication for <code>customerID</code> and allows the attacker to view invoice records matching <code>'Fax Machines'</code> for all customers.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>