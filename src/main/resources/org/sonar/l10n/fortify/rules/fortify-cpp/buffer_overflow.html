<h2>ABSTRACT</h2>
<p>
  Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or cause the execution of malicious code.
</p>
<h2>EXPLANATION</h2>
<p>
  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br />    <br />In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br /><br />Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3]. <br /><br />At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily overwrite the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br /><br />Buffer overflow vulnerabilities typically occur in code that:<br /><br />- Relies on external data to control its behavior.<br /><br />- Depends upon properties of the data that are enforced outside of the immediate scope of the code.<br /><br />- Is so complex that a programmer cannot accurately predict its behavior.<br /><br /><p><br />In this instance we are primarily concerned with the first scenario because:<br /><br />- External data enters the program at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>.<br /><br />- The data affects the manipulation of memory in <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br /><br />The following examples demonstrate all three of the scenarios.<br /><br /><b>Example 1.a:</b> The following sample code demonstrates a simple buffer overflow that is often caused by the first scenario in which the code  relies on external data to control its behavior. The code uses the <code>gets()</code> function to read an arbitrary amount of data into a stack buffer. Because there is no way to limit the amount of data read by this function, the safety of the code depends on the user to always enter fewer than <code>BUFSIZE</code> characters.<br /><br /><pre><br />	...<br />	char buf[BUFSIZE]; <br />	gets(buf);<br />	...<br /></pre><br /><br /><b>Example 1.b:</b> This example shows how easy it is to mimic the unsafe behavior of the <code>gets()</code> function in C++ by using the <code>&gt;&gt;</code> operator to read input into a <code>char[]</code> string. <br /><br /><pre><br />	...<br />	char buf[BUFSIZE]; <br />	cin &gt;&gt; (buf);<br />	...<br /></pre><br /><br /><b>Example 2:</b> The code in this example also relies on user input to control its behavior, but it adds a level of indirection with the use of the bounded memory copy function <code>memcpy()</code>. This function accepts a destination buffer, a source buffer, and the number of bytes to copy. The input buffer is filled by a bounded call to <code>read()</code>, but the user specifies the number of bytes that <code>memcpy()</code> copies.<br /><br /><pre><br />	...<br />char buf[64], in[MAX_SIZE];<br />printf("Enter buffer contents:\n");<br />read(0, in, MAX_SIZE-1);<br />printf("Bytes to copy:\n");<br />scanf("%d", &amp;bytes);<br />memcpy(buf, in, bytes);<br />	... <br /></pre><br /><br />Note: This type of buffer overflow vulnerability (where a program reads data and then trusts a value from the data in subsequent memory operations on the remaining data) has turned up with some frequency in image, audio, and other file processing libraries. <br />	<br /><b>Example 3:</b> This is an example of the second scenario in which the code depends on properties of the data that are not verified locally. In this example a function named <code>lccopy()</code> takes a string as its argument and returns a heap-allocated copy of the string with all uppercase letters converted to lowercase. The function performs no bounds checking on its input because it expects <code>str</code> to always be smaller than <code>BUFSIZE</code>. If an attacker bypasses checks in the code that calls <code>lccopy()</code>, or if a change in that code makes the assumption about the size of <code>str</code> untrue, then <code>lccopy()</code> will overflow <code>buf</code> with the unbounded call to <code>strcpy()</code>.<br /><br /><pre><br />char *lccopy(const char *str) {<br />	char buf[BUFSIZE];<br />	char *p;<br /><br />	strcpy(buf, str);<br />	for (p = buf; *p; p++) {<br />		if (isupper(*p)) {<br />			*p = tolower(*p);<br />		}<br />	}	<br />	return strdup(buf);<br />}<br /></pre><br /><br /><b>Example 4:</b> The following code demonstrates the third scenario in which the code is so complex its behavior cannot be easily predicted. This code is from the popular libPNG image decoder, which is used by a wide array of applications, including Mozilla and some versions of Internet Explorer. <br /><br />The code appears to safely perform bounds checking because it checks the size of the variable length, which it later uses to control the amount of data copied by <code>png_crc_read()</code>. However, immediately before it tests length, the code performs a check on <code>png_ptr-&gt;mode</code>, and if this check fails a warning is issued and processing continues. Because <code>length</code> is tested in an <code>else if</code> block, <code>length</code> would not be tested if the first check fails, and is used blindly in the call to <code>png_crc_read()</code>, potentially allowing a stack buffer overflow. <br /><br />Although the code in this example is not the most complex we have seen, it demonstrates why complexity should be minimized in code that performs memory operations. <br /><br /><pre><br />if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {<br />	/* Should be an error, but we can cope with it */<br />png_warning(png_ptr, "Missing PLTE before tRNS");<br />}<br />else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {<br />png_warning(png_ptr, "Incorrect tRNS chunk length");<br />png_crc_finish(png_ptr, length);<br />return;<br />}<br />...<br />png_crc_read(png_ptr, readbuf, (png_size_t)length);<br /></pre><br /><br /><b>Example 5:</b> This example also demonstrates the third scenario in which the program's complexity exposes it to buffer overflows. In this case, the exposure is due to the ambiguous interface of one of the functions rather than the structure of the code (as was the case in the previous example).<br /><br />The <code>getUserInfo()</code> function takes a username specified as a multibyte string and a pointer to a structure for user information, and populates the structure with information about the user. Since Windows authentication uses Unicode for usernames, the <code>username</code> argument is first converted from a multibyte string to a Unicode string. This function then incorrectly passes the size of <code>unicodeUser</code> in bytes rather than characters. The call to <code>MultiByteToWideChar()</code> may therefore write up to <code>(UNLEN+1)*sizeof(WCHAR)</code> wide characters, or<br /><code>(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)</code> bytes, to the <code>unicodeUser</code> array, which has only <code>(UNLEN+1)*sizeof(WCHAR)</code> bytes allocated. If the <code>username</code> string contains more than <code>UNLEN</code> characters, the call to <code>MultiByteToWideChar()</code> will overflow the buffer <code>unicodeUser</code>. <br /><br /><pre><br />void getUserInfo(char *username, struct _USER_INFO_2 info){<br />WCHAR unicodeUser[UNLEN+1];<br />	MultiByteToWideChar(CP_ACP, 0, username, -1,<br />    	      			unicodeUser, sizeof(unicodeUser));<br />NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);<br />}<br /></pre>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>