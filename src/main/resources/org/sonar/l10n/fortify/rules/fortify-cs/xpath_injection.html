<h2>ABSTRACT</h2>
<p>
  Constructing a dynamic XPath query with user input may allow an attacker to modify the statement's meaning. 
</p>
<h2>EXPLANATION</h2>
<p>
  XPath injection occurs when:<br /><br />1.       Data enters a program from an untrusted source.<br /><br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>.<br /></p><br /><IfDef var="ConditionalDescriptions"><br /> <p><br />  <ConditionalText condition="taint:number"><br />Even though the data in this case is a number, it is unvalidated and thus still considered malicious, hence the vulnerability is still reported but with reduced priority values.<br />  </ConditionalText><br /> </p><br /></IfDef><br /><br /><br />2.       The data used to dynamically construct an XPath query.<br /><br /><p><br />In this case the query is passed to <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br /><br /><b>Example 1:</b> The following code dynamically constructs and executes an XPath query that retrieves an e-mail address for a given account ID.  The account ID is read from an HTTP request, and is therefore untrusted.<br /><br /><pre><br />...<br />string acctID = Request[&quot;acctID&quot;];<br />string query = null;<br />if(acctID != null) {<br />       StringBuffer sb = new StringBuffer(&quot;/accounts/account[acctID='&quot;);<br />       sb.append(acctID);<br />       sb.append(&quot;']/email/text()&quot;);<br />       query = sb.toString();<br />}<br /><br />XPathDocument docNav = new XPathDocument(myXml);<br />XPathNavigator nav = docNav.CreateNavigator();<br />nav.Evaluate(query);<br />...<br /></pre><br /><br />Under normal conditions, such as searching for an e-mail address that belongs to the account number 1, the query that this code executes will look like the following:<br /><br /><code>/accounts/account[acctID='1']/email/text()</code><br /><br />However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>acctID</code> does not contain a single-quote character. If an attacker enters the string <code>1' or '1' = '1</code> for <code>acctID</code>, then the query becomes the following:<br /><br /><code>/accounts/account[acctID='1' or '1' = '1']/email/text()</code><br /><br />The addition of the <code>1' or '1' = '1</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br /><br /><code>//email/text()</code><br /><br />This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all e-mail addresses stored in the document, regardless of their specified owner.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>