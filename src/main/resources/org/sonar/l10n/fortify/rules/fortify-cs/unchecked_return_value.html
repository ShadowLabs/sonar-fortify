<h2>ABSTRACT</h2>
<p>
  Ignoring a method's return value can cause the program to overlook unexpected states and conditions.
</p>
<h2>EXPLANATION</h2>
<p>
  It is not uncommon for programmers to misunderstand <code>Read()</code> and related methods that are part of many <code>System.IO</code> classes. Most errors and unusual events in .NET result in an exception being thrown. (This is one of the advantages that .NET has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.)  But the stream and reader classes do not consider it to be unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.<br /><br />This behavior makes it important for programmers to examine the return value from <code>Read()</code> and other IO methods and ensure that they receive the amount of data they expect.<br /><p><br />In this case the value of <Replace key="PrimaryCall.name" link="PrimaryLocation"/> is unchecked in <Replace key="PrimaryLocation.file"/> at line <Replace key="PrimaryLocation.line"/>.<br /></p><br /><b>Example:</b> The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always 1 kilobyte in size and therefore ignores the return value from <code>Read()</code>. If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.<br /><br /><pre><br />char[] byteArray = new char[1024];<br />for (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {<br />    string userName = (string) i.Current();<br />    string pFileName = PFILE_ROOT + "/" + userName;<br />    StreamReader sr = new StreamReader(pFileName);   <br />    sr.Read(byteArray,0,1024);//the file is always 1k bytes<br />    sr.Close();<br />    processPFile(userName, byteArray);<br />}<br /></pre>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>