<h2>ABSTRACT</h2>
<p>
  The program can potentially use a variable before it has been initialized.
</p>
<h2>EXPLANATION</h2>
<p>
  Stack variables in C and C++ are not initialized by default. Their initial values are determined by whatever happens to be in their location on the stack at the time the function is invoked. Programs should never use the value of an uninitialized variable.<br /><p><br />In this case, the variable declared in <Replace key="FirstTraceLocation.file"/> at line <Replace key="FirstTraceLocation.line"/> can be used at line <Replace key="PrimaryLocation.line"/> without being set first.<br /></p><br />It is not uncommon for programmers to use an uninitialized variable in code that handles errors or other rare and exceptional circumstances. Uninitialized variable warnings can sometimes indicate the presence of a typographic error in the code. <br /><br /><b>Example 1:</b> The following switch statement is intended to set the values of the variables <code>aN</code> and <code>bN</code>, but in the default case, the programmer has accidentally set the value of <code>aN</code> twice.<br /><br /><pre><br />switch (ctl) {<br />  case -1:<br />    aN = 0; bN = 0;<br />    break;<br />  case 0:<br />    aN = i; bN = -i;<br />    break;<br />  case 1:<br />    aN = i + NEXT_SZ; bN = i - NEXT_SZ;<br />    break;<br />  default:<br />    <b>aN = -1; aN = -1;</b><br />    break;<br />}<br /><br /></pre><br /><br />Most uninitialized variable issues result in general software reliability problems, but if attackers can intentionally trigger the use of an uninitialized variable, they might be able to launch a denial of service attack by crashing the program. Under the right circumstances, an attacker may be able to control the value of an uninitialized variable by affecting the values on the stack prior to the invocation of the function.
</p>
<h2>REFERENCES</h2>
<p>
  
</p>