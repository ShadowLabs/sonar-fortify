<h2>ABSTRACT</h2>
<p>
  Sending unvalidated data to a web browser can result in the browser executing malicious code.
</p>
<h2>EXPLANATION</h2>
<p>
  Cross-site scripting (XSS) vulnerabilities occur when:<br /><br />1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.<br /><br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>. <br /></p><br />2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. <br /><p><br />In this case the data is sent at <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br />The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br /><br /><b>Example 1:</b> The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.<br /><IfNotDef var="ConditionalDescriptions"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />EmployeeID.Text = Login.Text;<br />...<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   &lt;asp:TextBox runat="server" id="Login"/&gt;<br />   ...<br />   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br />&lt;/form&gt;<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="trace:/System\.Web\.UI\.(WebControls|HtmlControls)/"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />EmployeeID.Text = Login.Text;<br />...<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   &lt;asp:TextBox runat="server" id="Login"/&gt;<br />   ...<br />   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br />&lt;/form&gt;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:System.IO.TextWriter sink:System.Web.HttpResponse trace:!/WebControls|HtmlControls/"><br /><pre><br />&lt;%= Request.Form["Login"] %&gt;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:!/System\.IO\.TextWriter|System\.Web\.HttpResponse/ trace:!/WebControls|HtmlControls/"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />EmployeeID.Text = Login.Text;<br />...<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   &lt;asp:TextBox runat="server" id="Login"/&gt;<br />   ...<br />   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br />&lt;/form&gt;<br /></pre><br /></ConditionalText><br /></p></IfDef><br /><br /><b>Example 2:</b> The following ASP.NET code segment shows the programmatic way to implement Example 1 above.<br /><IfNotDef var="ConditionalDescriptions"><br /><pre><br />protected System.Web.UI.WebControls.TextBox Login;<br />protected System.Web.UI.WebControls.Label EmployeeID;<br />...<br />EmployeeID.Text = Login.Text;<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="trace:/System\.Web\.UI\.(WebControls|HtmlControls)/"><br /><pre><br />protected System.Web.UI.WebControls.TextBox Login;<br />protected System.Web.UI.WebControls.Label EmployeeID;<br />...<br />EmployeeID.Text = Login.Text;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:System.IO.TextWriter sink:System.Web.HttpResponse trace:!/WebControls|HtmlControls/"><br /><pre><br />string ID = Request.Form["Login"];<br />Response.Write(ID);<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:!/System\.IO\.TextWriter|System\.Web\.HttpResponse/ trace:!/WebControls|HtmlControls/"><br /><pre><br />protected System.Web.UI.WebControls.TextBox Login;<br />protected System.Web.UI.WebControls.Label EmployeeID;<br />...<br />EmployeeID.Text = Login.Text;<br /></pre><br /></ConditionalText><br /></p></IfDef><br /><br />The code in these examples operates correctly if <code>Login</code> contains only standard alphanumeric text. If <code>Login</code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.<br /><br />Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.<br /><br /><b>Example 3:</b> The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.<br /><IfNotDef var="ConditionalDescriptions"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>EmployeeName</code> is a form control defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   ...<br />   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br />   ...<br />&lt;/form&gt;<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="trace:/System\.Web\.UI\.(WebControls|HtmlControls)/"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>EmployeeName</code> is a form control defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   ...<br />   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br />   ...<br />&lt;/form&gt;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:System.IO.TextWriter sink:System.Web.HttpResponse trace:!/WebControls|HtmlControls/"><br /><pre><br />&lt;%<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />%&gt;<br />...<br />Employee Name: &lt;%= name %&gt;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:!/System\.IO\.TextWriter|System\.Web\.HttpResponse/ trace:!/WebControls|HtmlControls/"><br /><pre><br />&lt;script runat="server"&gt;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br />&lt;/script&gt;<br /></pre><br /><br />Where <code>EmployeeName</code> is a form control defined as follows:<br /><br /><pre><br />&lt;form runat="server"&gt;<br />   ...<br />   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br />   ...<br />&lt;/form&gt;<br /></pre><br /></ConditionalText><br /></p></IfDef><br /><br /><b>Example 4:</b> The following ASP.NET code segment is functionally equivalent to Example 3 above, but implements all of the form elements programmatically.<br /><IfNotDef var="ConditionalDescriptions"><br /><pre><br />protected System.Web.UI.WebControls.Label EmployeeName;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="trace:/System\.Web\.UI\.(WebControls|HtmlControls)/"><br /><pre><br />protected System.Web.UI.WebControls.Label EmployeeName;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:System.IO.TextWriter sink:System.Web.HttpResponse trace:!/WebControls|HtmlControls/"><br /><pre><br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />Response.Write("Employee Name: " + name);<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:!/System\.IO\.TextWriter|System\.Web\.HttpResponse/ trace:!/WebControls|HtmlControls/"><br /><pre><br />protected System.Web.UI.WebControls.Label EmployeeName;<br />...<br />string query = "select * from emp where id=" + eid;<br />sda = new SqlDataAdapter(query, conn);<br />DataTable dt = new DataTable();<br />sda.Fill(dt);<br />string name = dt.Rows[0]["Name"];<br />...<br />EmployeeName.Text = name;<br /></pre><br /></ConditionalText><br /></p></IfDef><br /><br />As in Examples 1 and 2, these code examples function correctly when the values of <code>name</code> are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of <code>name</code> is read from a database, whose contents are apparently managed by the application. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br /><br />As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:<br /><br />- As in Examples 1 and 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br /><br />- As in Examples 3 and 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br /><br />- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.<br /><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="tracenode:default validation enabled for application tracenode:default validation enabled on page">A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</ConditionalText><br /></p></IfDef><br /><IfNotDef var="ConditionalDescriptions"><br />A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br /></IfNotDef>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>