<h2>ABSTRACT</h2>
<p>
  Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.
</p>
<h2>EXPLANATION</h2>
<p>
  Database access control errors occur when:<br /><br />1. Data enters a program from an untrusted source.<br /><p><br />In this case the data enters at <Replace key="SourceFunction" link="SourceLocation"/> in <Replace key="SourceLocation.file"/> at line <Replace key="SourceLocation.line"/>. <br /></p><br />2. The data is used to specify the value of a primary key in a SQL query. <br /><p><br />In this case the data is used by <Replace key="SinkFunction" link="SinkLocation"/> in <Replace key="SinkLocation.file"/> at line <Replace key="SinkLocation.line"/>.<br /></p><br /><br /><IfNotDef var="ConditionalDescriptions"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />SqlCommand query = new SqlCommand( <br />            "SELECT * FROM invoices WHERE id = @id", conn);<br />query.Parameters.AddWithValue("@id", id);<br />SqlDataReader objReader = query.ExecuteReader();<br />...<br /></pre><br /></IfNotDef><br /><IfDef var="ConditionalDescriptions"><br /><ConditionalText condition="sink:System.Data"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />SqlCommand query = new SqlCommand( <br />            "SELECT * FROM invoices WHERE id = @id", conn);<br />query.Parameters.AddWithValue("@id", id);<br />SqlDataReader objReader = query.ExecuteReader();<br />...<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:NHibernate"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />Query query = sess.CreateQuery("SELECT * FROM invoices WHERE id = ?");<br />query.SetInt16(0, id);<br />List&lt;Invoice&gt; items = query.List&lt;Invoice&gt;();<br /></pre><br /><br /><b>Example 2:</b> The following code performs the analogous query using NHibernate's HQL syntax and named parameters.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />Query query = sess.CreateQuery("FROM Invoice inv WHERE inv.Id = :id");<br />query.SetInt16("id", id);<br />List&lt;Invoice&gt; items = query.List&lt;Invoice&gt;();<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:SubSonic"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />string query = new SqlCommand( <br />            "SELECT * FROM invoices WHERE id = @id", conn);<br />Object[] parameters = { id };<br />IDataReader responseReader = new InlineQuery().ExecuteReader(query, parameters);<br />...<br /></pre><br /><br /><b>Example 2:</b> The following code uses SubSonic 2's simple query tools to achieve the same effect.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />InvoiceCollection inv = new Select().From("invoices").<br />            Where("id").IsEqualTo(id).ExecuteAsCollection&lt;InvoiceCollection&gt;();<br /></pre><br /><br /><b>Example 3:</b> The following is the ActiveRecord Fluent Query version of the above examples, implemented in SubSonic 3.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />List&lt;Invoice&gt; invoices = db.Select.From&lt;Invoice&gt;().<br />            Where(InvoiceTable.IDColumn).IsEqualTo(id).ExecuteTypedList&lt;Invoice&gt;();<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:Castle.ActiveRecord"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />string queryString = "SELECT * FROM invoices WHERE id = :id";<br />SimpleQuery&lt;Invoice&gt; q = new SimpleQuery(queryString);<br />q.SetParameter("id", id);<br />Invoice[] invoices = (Invoice []) q.Execute();<br /></pre><br /></ConditionalText><br /><ConditionalText condition="sink:!System.Data sink:!NHibernate sink:!SubSonic sink:!Castle.ActiveRecord"><br /><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br /><br /><pre><br />...<br />int16 id = System.Convert.ToInt16(invoiceID.Text);<br />SqlCommand query = new SqlCommand( <br />            "SELECT * FROM invoices WHERE id = @id", conn);<br />query.Parameters.AddWithValue("@id", id);<br />SqlDataReader objReader = query.ExecuteReader();<br />...<br /></pre><br /></ConditionalText><br /></IfDef><br /><br />The problem is that the developer has failed to consider all of the possible values of <code>id</code>. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.<br /><br /><IfDef var="ConditionalDescriptions"><p><br /><ConditionalText condition="tracenode:default validation enabled for application tracenode:default validation enabled on page">A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</ConditionalText><br /></p></IfDef><br /><IfNotDef var="ConditionalDescriptions"><br />A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the Fortify Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br /></IfNotDef>
</p>
<h2>REFERENCES</h2>
<p>
  
</p>